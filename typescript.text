https://ts.xcatliu.com/
https://www.runoob.com/typescript/ts-module.html

install typescript

https://www.typescriptlang.org/download

npm -g install typescript

npm -install
npm -start

tsc app       compile a .ts deocument to .js document


so here is the logic:     ts -->  js  -->  html


1. typescript project file
 
   create tsconfig.json
   
   tsc -init
   
2. make compilation automately

 1> set tsconfig.json
   {
  "compilerOptions": {
   
    "target": "es5" 
    "module": "commonjs",
    "sourceMap": true,
    "outDir": "js",
    "strict": true ,
    "skipLibCheck": true ,
    "watch": true
   },
  "files": ["app/app.ts"]
  }
 2> delete app.js
 3> tsc
 4> <script src="/app/app.js"></script>    ===>>>  <script src="/js/app.js"></script>      // ts will compile to js automately while running the file under js file

3. inherited tsconfig.json

  1> delete "files": ["app/app.ts"]
  2> rename tsconfig.json  to tsconfig.base.json
  3> create tsconfig.json under app file
  4> edit tsconfig.json
     {
       "extends": "../tsconfig.base",
       "compilerOptions": {
         "removeComments": true
       },
       "inlcude": ["./**/*"]
     }

4. multiple ts sources
   https://app.pluralsight.com/course-player?clipId=09f4f9ce-0128-4cbc-9d8b-2b0c68e56f9a  
   https://app.pluralsight.com/course-player?clipId=220d8851-fd35-41bd-94d2-7e24bb009cdf

1. typescript types

1. boolean 
2. number
3. string
4. Array
5. Enum

6.void
7.null
8.undefined
9.never
10.any


2. declarations with let/const

   1.let
   2.const

3. type annotation and type inference

   let x: string = "this is typescript";    
   x = 42;                                    //wrong, cannot change type as javascript

   let z = number = getNumber();
   
4. union types

   let someValue: number | string
   
   someValue= 42;
   someValue= "This is string";
   
*5 strict Null check 
   
   let a: string = "123";
   a = null;                //wrong
   
   let b: string | null;
   b = null;                 //right
   b = undefined;            //wrong
   
   let c: string | null | undefined;
   c = "123";
   c = null;
   c = undefined;
   
6. type annotations of functions

   function func(score: number, message: string): string{
       return "this is a sentence";
   }
   
*7. default-initialized parameters

    function sendGreeting(greeting: string = "Good morning!"): void {
         console.log(greeting);
    }
   
    sendGreeting();                       // Good morning
    sendGreeting("Good afternoon");       // Good afternoon
   
 8. arrow function
 
    let adder = (a, b) => a + b;
   
9. custom types

   interfaces and classes
   
   
   interface Employee {
         name: string;                               //must have
         age?: number;                               //may have
         [propName:string]: string;                  //byyourself
   }
   
   interface Manager extends Employee{
         department: string;
         numOfEmployees: number;
         schedulMeeting: (topic: string) => void;
   }
   
   let newOne : Employee = {
         name: "Tom",                                // , not ;
         gender: "male"
   };


   class Developer {
         department: string;
         private _title: string;
         get title(): string{
              return this._title;
         }
         set title(newTitle: string){
              this._title = newTitle.toUpperCase();
         }
   
   }
   
   
   constructor
   
   class Developer{
         constructor(){
             console.log("try one");
         }
   }
   
   class WebDeveloper extends Developer{
         favouriteEditor: string;
         constructor(editor: string){
             super();
             this.favouritEditor = editor;
         }
   }
   
   
   
   10. modules
   
       why we use modules?
       1. encapsulation
       2. reusability
       3. higher-level abstractions
   
       从ECMAScript 2015开始，JavaScript引入了模块的概念。TypeScript也沿用这个概念。
       
       模块在其自身的作用域里执行，而不是在全局作用域里；
       这意味着定义在一个模块里的变量，函数，类等等在模块外部是不可见的，除非你明确地使用export形式之一导出它们。 
       相反，如果想使用其它模块导出的变量，函数，类，接口等的时候，你必须要导入它们，可以使用 import形式之一。
       
       模块使用模块加载器去导入其它的模块。 在运行时，模块加载器的作用是在执行此模块代码前去查找并执行这个模块的所有依赖。 
       JavaScript模块加载器是服务于Node.js的 CommonJS和服务于Web应用的Require.js。
       
       TypeScript与ECMAScript 2015一样，任何包含顶级import或者export的文件都被当成一个模块。
       相反地，如果一个文件不带有顶级的import或者export声明，那么它的内容被视为全局可见的（因此对模块也是可见的）。
       
       
       1、export与export default均可用于导出常量、函数、文件、模块等
       2、你可以在其它文件或模块中通过import+(常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用
       3、在一个文件或模块中，export、import可以有多个，export default仅有一个
       4、通过export方式导出，在导入时要加{ }，export default则不需要
       
       
       
       exporting a declaration
       
       export interface Person{}
       export function hirePerson(): void{}
       export default class Employee{}
   
   
   
       export statements
   
       interface Person{}
       function hirePerson(): void{}
       class Employee{}
       
       export{Person, HirePerson, Employee};
   
   
       importing from a module
       
       import {Person, hireDeveloper} from "./person"
       let human: Person;
       
       import Employee from "./person";
       
       import * as HR from "./person";
       
       
       
       
       
