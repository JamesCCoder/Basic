https://ts.xcatliu.com/


install typescript

https://www.typescriptlang.org/download

npm -g install typescript

npm -install
npm -start

tsc -app       compile a .ts deocument to .js document


so here is the logic:     ts -->  js  -->  html


1. typescript project file
 
   create tsconfig.json
   
   tsc -init
   
2. make compilation automately

 1> set tsconfig.json
   {
  "compilerOptions": {
   
    "target": "es5" 
    "module": "commonjs",
    "sourceMap": true,
    "outDir": "js",
    "strict": true ,
    "skipLibCheck": true ,
    "watch": true
   },
  "files": ["app/app.ts"]
  }
 2> delete app.js
 3> tsc
 4> <script src="/app/app.js"></script>    ===>>>  <script src="/js/app.js"></script>      // ts will compile to js automately while running the file under js file

3. inherited tsconfig.json

  1> delete "files": ["app/app.ts"]
  2> rename tsconfig.json  to tsconfig.base.json
  3> create tsconfig.json under app file
  4> edit tsconfig.json
     {
       "extends": "../tsconfig.base",
       "compilerOptions": {
         "removeComments": true
       },
       "inlcude": ["./**/*"]
     }

4. multiple ts sources
   https://app.pluralsight.com/course-player?clipId=09f4f9ce-0128-4cbc-9d8b-2b0c68e56f9a  
   https://app.pluralsight.com/course-player?clipId=220d8851-fd35-41bd-94d2-7e24bb009cdf

1. typescript types

1. boolean 
2. number
3. string
4. Array
5. Enum

6.void
7.null
8.undefined
9.never
10.any


2. declarations with let/const

   1.let
   2.const

3. type annotation and type inference

   let x: string = "this is typescript";    
   x = 42;                                    //wrong, cannot change type as javascript

   let z = number = getNumber();
   
4. union types

   let someValue: number | string
   
   someValue= 42;
   someValue= "This is string";
   
*5 strict Null check 
   
   let a: string = "123";
   a = null;                //wrong
   
   let b: string | null;
   b = null;                 //right
   b = undefined;            //wrong
   
   let c: string | null | undefined;
   c = "123";
   c = null;
   c = undefined;
   
6. type annotations of functions

   function func(score: number, message: string): string{
       return "this is a sentence";
   }
   
*7. default-initialized parameters

    function sendGreeting(greeting: string = "Good morning!"): void {
         console.log(greeting);
    }
   
    sendGreeting();                       // Good morning
    sendGreeting("Good afternoon");       // Good afternoon
   
 8. arrow function
 
    let adder = (a, b) => a + b;
   
9. custom types

   interfaces and classes
   
   
   interface Employee {
         name: string;                               //must have
         age?: number;                               //may have
         [propName:string]: string;                  //byyourself
   }
   
   interface Manager extends Employee{
         department: string;
         numOfEmployees: number;
         schedulMeeting: (topic: string) => void;
   }
   
   let newOne : Employee = {
         name: "Tom",                                // , not ;
         gender: "male"
   };


   class Developer {
         department: string;
         private _title: string;
         get title(): string{
              return this._title;
         }
         set title(newTitle: string){
              this._title = newTitle.toUpperCase();
         }
   
   }
   
   
   constructor
   
   class Developer{
         constructor(){
             console.log("try one");
         }
   }
   
   class WebDeveloper extends Developer{
         favouriteEditor: string;
         constructor(editor: string){
             super();
             this.favouritEditor = editor;
         }
   }
   
   
   
   10. modules
   
       why we use modules?
       1. encapsulation
       2. reusability
       3. higher-level abstractions
   
   
   
   
   
   
   
